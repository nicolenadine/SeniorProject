import os
import argparse
import random
import numpy as np
from tqdm import tqdm
import time
from PIL import Image
import matplotlib.pyplot as plt
import glob
from malware_image_generator import MalwareImageGenerator


def find_malware_files(data_dir, samples_per_family=750):
    """
    Get paths to malware opcode files, sampling equally from each family

    Args:
        data_dir: Path to the Data directory
        samples_per_family: Number of samples to take from each family

    Returns:
        Dictionary mapping family names to lists of file paths
    """
    file_paths_by_family = {}

    # Look specifically in the Malware folder
    malware_dir = os.path.join(data_dir, "Malware")

    if not os.path.exists(malware_dir):
        print(f"Error: Malware directory not found at {malware_dir}")
        return file_paths_by_family

    print(f"Found malware directory: {malware_dir}")

    # Get all family directories
    family_dirs = [d for d in os.listdir(malware_dir)
                   if os.path.isdir(os.path.join(malware_dir, d))]

    print(f"Found {len(family_dirs)} malware family directories")

    # Process each family
    for family in family_dirs:
        family_dir = os.path.join(malware_dir, family)
        all_files = []

        # Get all files in this family directory
        for root, _, files in os.walk(family_dir):
            for file in files:
                all_files.append(os.path.join(root, file))

        # Sample files from this family
        if len(all_files) <= samples_per_family:
            # If we have fewer files than requested, take all of them
            sampled_files = all_files
            print(f"Family {family}: Using all {len(sampled_files)} available files")
        else:
            # Otherwise, take a stratified sample
            # Sort files to ensure deterministic sampling
            all_files.sort()
            # Use a deterministic sampling approach to get evenly distributed files
            step = len(all_files) / samples_per_family
            indices = [int(i * step) for i in range(samples_per_family)]
            sampled_files = [all_files[i] for i in indices]
            print(f"Family {family}: Sampled {len(sampled_files)} files from {len(all_files)} total")

        file_paths_by_family[family] = sampled_files

    # Print summary
    total_files = sum(len(files) for files in file_paths_by_family.values())
    print(f"Total malware files selected: {total_files} from {len(family_dirs)} families")

    return file_paths_by_family


def process_batch(file_batch, generator, global_frequencies, min_opcodes, family=None):
    """
    Process a batch of files and return statistics

    Args:
        file_batch: List of file paths to process
        generator: MalwareImageGenerator instance
        global_frequencies: Dictionary of global opcode frequencies
        min_opcodes: Minimum number of opcodes required
        family: Name of the malware family (for naming output files)

    Returns:
        Dictionary with batch statistics
    """
    batch_stats = {"processed": 0, "skipped": 0, "errors": 0}

    for file_path in file_batch:
        try:
            # Read opcodes
            with open(file_path, 'r', errors='ignore') as f:
                opcodes = f.read().strip().split()

            # Skip files with too few opcodes
            if len(opcodes) < min_opcodes:
                batch_stats["skipped"] += 1
                continue

            # Generate malware image using the Hilbert mapping
            img_data = generator.hilbert_mapping(opcodes, global_frequencies)

            # Create output filename that includes family information
            original_filename = os.path.basename(file_path)

            # Create family-specific folder in output directory
            family_dir = os.path.join(generator.output_dir, "malware", family)
            os.makedirs(family_dir, exist_ok=True)

            # Create output path with family information
            output_path = os.path.join(family_dir, f"{family}_{original_filename}.png")

            # Save the image directly instead of using _save_image
            img_data_uint8 = (img_data * 255).astype(np.uint8)
            img = Image.fromarray(img_data_uint8, 'L')  # 'L' mode for grayscale
            img.save(output_path)

            batch_stats["processed"] += 1

        except Exception as e:
            print(f"Error processing {file_path}: {e}")
            batch_stats["errors"] += 1

    return batch_stats


def main():
    # Parse command line arguments
    parser = argparse.ArgumentParser(description="Generate malware images from opcode files")
    parser.add_argument("--data_dir", type=str, required=True,
                        help="Directory containing the Data folder with Malware subfolder")
    parser.add_argument("--w2v_model", type=str, required=True, help="Path to trained Word2Vec model")
    parser.add_argument("--output_dir", type=str, default="./generated_images", help="Output directory for images")
    parser.add_argument("--batch_size", type=int, default=100, help="Number of files to process in each batch")
    parser.add_argument("--min_opcodes", type=int, default=1000, help="Minimum number of opcodes required")
    parser.add_argument("--img_size", type=int, default=256, help="Size of generated images (square)")
    parser.add_argument("--samples_per_family", type=int, default=750,
                        help="Number of samples to take from each malware family")
    parser.add_argument("--random_seed", type=int, default=42, help="Random seed for reproducibility")

    args = parser.parse_args()

    # Set random seed for reproducibility
    random.seed(args.random_seed)
    np.random.seed(args.random_seed)

    # Initialize the generator
    generator = MalwareImageGenerator(
        w2v_model_path=args.w2v_model,
        output_dir=args.output_dir,
        img_size=(args.img_size, args.img_size)
    )

    # Find malware files by family
    print(f"Looking for malware files in {args.data_dir}")
    malware_files_by_family = find_malware_files(args.data_dir, args.samples_per_family)

    if not malware_files_by_family:
        print("No malware files found. Exiting.")
        return

    # Count total files to be processed
    total_files = sum(len(files) for files in malware_files_by_family.values())
    print(f"Selected {total_files} malware files from {len(malware_files_by_family)} families")

    # Create the global opcode frequencies only once
    # Using a different approach than in the MalwareImageGenerator class
    print("Calculating global opcode frequencies...")
    global_frequencies = {}

    # Use a small random sample of files to calculate frequencies
    # to avoid processing all files which would be slow
    all_files = []
    for files in malware_files_by_family.values():
        all_files.extend(files)

    # Randomly sample up to 1000 files for frequency calculation
    if len(all_files) > 1000:
        freq_sample = random.sample(all_files, 1000)
    else:
        freq_sample = all_files

    # Process the sampled files to calculate frequencies
    all_opcodes = []
    for file_path in tqdm(freq_sample, desc="Calculating frequencies"):
        try:
            with open(file_path, 'r', errors='ignore') as f:
                opcodes = f.read().strip().split()
                # Sample a subset for very large files
                if len(opcodes) > 10000:
                    indices = np.random.choice(len(opcodes), 10000, replace=False)
                    opcodes = [opcodes[i] for i in indices]
                all_opcodes.extend(opcodes)
        except Exception as e:
            print(f"Error reading {file_path}: {e}")

    # Calculate frequencies
    total_count = len(all_opcodes)
    for op in all_opcodes:
        if op in global_frequencies:
            global_frequencies[op] += 1
        else:
            global_frequencies[op] = 1

    # Convert to relative frequencies
    for op in global_frequencies:
        global_frequencies[op] /= total_count

    print(f"Calculated frequencies for {len(global_frequencies)} unique opcodes")

    # Process files by family
    total_stats = {"processed": 0, "skipped": 0, "errors": 0}
    start_time = time.time()

    # Create the malware directory
    os.makedirs(os.path.join(args.output_dir, "malware"), exist_ok=True)

    for family, files in malware_files_by_family.items():
        print(f"\nProcessing family: {family} ({len(files)} files)")
        family_stats = {"processed": 0, "skipped": 0, "errors": 0}

        # Process this family in batches
        for i in tqdm(range(0, len(files), args.batch_size), desc=f"Family {family}"):
            batch = files[i:i + args.batch_size]
            batch_stats = process_batch(batch, generator, global_frequencies, args.min_opcodes, family)

            # Update family stats
            for key in family_stats:
                family_stats[key] += batch_stats[key]

        # Print family statistics
        print(f"Family {family} statistics:")
        print(f"  - Images generated: {family_stats['processed']}")
        print(f"  - Files skipped (too small): {family_stats['skipped']}")
        print(f"  - Errors encountered: {family_stats['errors']}")

        # Update total stats
        for key in total_stats:
            total_stats[key] += family_stats[key]

    # Print final statistics
    elapsed_time = time.time() - start_time
    print(f"\nProcessing complete in {elapsed_time:.2f} seconds")
    print(f"Total statistics:")
    print(f"  - Malware images generated: {total_stats['processed']}")
    print(f"  - Files skipped (too small): {total_stats['skipped']}")
    print(f"  - Errors encountered: {total_stats['errors']}")

    # Create sample visualizations
    print("Generating visualization samples...")
    # Create a modified version of the visualization that shows samples from each family
    try:
        # Create a figure with samples from each family
        num_families = len(malware_files_by_family)
        samples_per_family = min(5, 20 // num_families)  # Adjust samples based on family count

        # Create a grid of subplots
        rows = min(num_families, 5)  # Limit to 5 rows
        cols = samples_per_family

        fig, axes = plt.subplots(rows, cols, figsize=(cols * 3, rows * 3))

        # Handle axes dimensionality for different cases
        # Convert to a 2D numpy array of Axes objects
        if rows == 1 and cols == 1:
            # Single subplot case - make a 2D array with the single axes
            axes = np.array([[axes]])
        elif rows == 1:
            # Single row case - reshape to 2D array with one row
            axes = np.array([axes])
        elif cols == 1:
            # Single column case - reshape to 2D array with one column
            axes = np.array([[ax] for ax in axes])

        # Get samples for each family
        for i, (family, _) in enumerate(list(malware_files_by_family.items())[:rows]):
            family_dir = os.path.join(generator.output_dir, "malware", family)
            family_files = glob.glob(os.path.join(family_dir, "*.png"))

            if not family_files:
                continue

            # Sample files
            if len(family_files) > cols:
                family_samples = random.sample(family_files, cols)
            else:
                family_samples = family_files

            # Display family samples
            for j, file_path in enumerate(family_samples):
                if j < cols:
                    img = Image.open(file_path)
                    axes[i, j].imshow(img, cmap='gray')
                    axes[i, j].set_title(f"{family}")
                    axes[i, j].axis('off')

        plt.tight_layout()
        plt.savefig(os.path.join(generator.output_dir, "family_samples.png"))
        plt.close()

        # Regular visualizations
        generator.visualize_embedding_space()
        generator.visualize_hilbert_curve()
        print("Visualizations created successfully")

    except Exception as e:
        print(f"Error creating visualizations: {e}")

    print("All done!")


if __name__ == "__main__":
    main()